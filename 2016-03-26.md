# 2016-03-26

### [观察者模式1](http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html)

### [观察者模式2](http://design-patterns.readthedocs.org/zh_CN/latest/behavioral_patterns/observer.html)

### [状态模式](http://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html)

### [策略模式](http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html)

### Service

既然在Service里也要创建一个子线程，那为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。

### AIDL
#### [AIDL基本](http://blog.csdn.net/guolin_blog/article/details/9797169)  
#### [AIDL在AS中](http://blog.csdn.net/shenzhonglaoxu/article/details/42737195)  
#### [Android5.0的bug解决办法](http://blog.csdn.net/shenzhonglaoxu/article/details/42675287)

### Notification
```java
Notification.Builder builder = new Notification.Builder(this);
builder.setContentTitle("Title");
builder.setContentText("Context");
builder.setSmallIcon(R.drawable.github);
builder.setOngoing(true);

Notification notification;
if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    notification = builder.build();
} else {
    notification = builder.getNotification();
}

((NotificationManager) getSystemService(NOTIFICATION_SERVICE)).notify(1, notification);
```

### [return & finally](http://www.cnblogs.com/lanxuezaipiao/p/3440471.html)
