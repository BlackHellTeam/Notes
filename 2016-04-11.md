#2016-04-11

### [Loading Large Bitmaps Efficiently](http://developer.android.com/intl/zh-cn/training/displaying-bitmaps/load-bitmap.html)

### 安卓性能优化总结
#### 内存泄露
##### 了解GC机制，理解四种引用在GC机制下的表现和发挥的作用
##### 长期存在的对象引用了短期存在的对象，使得短期存在的对象无法销毁，比如单例模式持有对某短期存在对象的引用
##### 长期存在的对象引用了短期存在的对象，使得短期存在的对象无法销毁，比如静态内部类对外部类的引用
关于静态内部类，可以看[这篇文章](http://www.cnblogs.com/chenssy/p/3388487.html)对静态内部类的解释，注意最后一点：
> 在java提高篇-----关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内> 部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着>> 一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。

也就是说，静态内部类本身就有用于避免内存的特质，因为它不会对外部类保存引用。比如最常见的是Handler类的编写不规范，具体可以参见[这篇文章](http://hanhailong.com/2015/12/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/)，注意其中说到：
> 这种创建Handler的方式会造成内存泄漏，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。

> 创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息。

> 使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages();来移除指定的Runnable和Message。

注意这里的这种情况又扯到了Android中的消息机制，Looper和消息队列的概念，而这些又可以扯到ThreadLocal和线程安全。

但是如果我们再静态内部类中引用了外部的对象，这个时候静态内部类所具有的不引用外部类的特质就被人为破坏了，所以这个时候我们就需要用弱引用来持有这个对外部类的引用。

##### 长期存在的对象引用了短期存在的对象，使得短期存在的对象无法销毁，比如生命周期比Activity长的线程持有对Activity的引用
注意手机屏幕旋转的时候的处理。
> 如果你的任务需要更新 UI，那么考虑用 AsyncTask 吧，AsyncTask 虽然相对容易，但是有些坑得留意。当你旋转手机的时候，Activity 会被关闭，然后重启。不然可能造成内存泄露。

##### 长期存在的对象引用了短期存在的对象，使得短期存在的对象无法销毁，比如无线循环的属性动画没有在Activity的onDestroy中停止

##### 资源未关闭造成的内存泄漏
对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。

##### 一般怎么知道内存泄露？
1. MAT分析内存状况，重点分析重复的对象、bitmap对象，分析引用路径。
2. [LeakCanary](https://github.com/square/leakcanary)

#### 加载大图
[Loading Large Bitmaps Efficiently](http://developer.android.com/intl/zh-cn/training/displaying-bitmaps/load-bitmap.html)

1. 先得到图的长宽
2. 计算最小应加载多大，计算采样率
3. 加载

#### 不要在主线程中解析JSON数据，可以用某些比较快的JSON解析库
比如[ig-json-parser](https://github.com/Instagram/ig-json-parser)，[jackson](https://github.com/FasterXML/jackson)。

#### 不要在主线程中读数据库

#### 判断当前线程是否为主线程```Looper.myLooper() == Looper.getMainLooper() ```

#### 不要通过反射来调用私有 API

#### 良好的代码规范：私有成员用m，静态成员用s，常量全大写

#### 布局优化
1. 布局层级能少就少
2. 在同样布局层级的前提下，用简单的ViewGroup，比如FrameLayout和LinearLayout
3. <include>标签可以帮助我们复用布局
4. 在用<include>标签复用布局的时候，可以用<merge>标签减少布局层级
5. 用ViewStub来缓加载布局

#### 绘制优化
1. onDraw中不要创建对象，onDraw有可能频繁调用，这样会产生大量无用对象
2. onDraw中不要进行耗时操作，影响帧率

#### 通过traces文件分析ANR原因

#### 使用线程池

